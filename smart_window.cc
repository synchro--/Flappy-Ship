#include "agl.h"

#include <GL/glu.h>
#include <SDL2/SDL.h>

/*
 * window.cc provides a concrete implementation for gl::Window, a class that
 * represents a graphical window.
 *
 * Window takes care of initializing the GL context and an SDL_Window.
 */

namespace agl {
// creates a new Window with the required parameters.
SmartWindow::SmartWindow(std::string &name, size_t x, size_t y, size_t w,
                         size_t h)
    : m_name(name), m_width(w), m_height(h), m_env(get_env()) {

  static const auto TAG = __func__;

  lg::i(TAG, "creating Window(\"%s\", %zu, %zu, %zu, %zu)", name.c_str(), x, y,
        w, h);

  m_win = SDL_CreateWindow(m_name.c_str(), x, y, w, h, SDL_WINDOW_OPENGL);

  if (!m_win) {
    lg::e(TAG, "Window error: ", SDL_GetError());
  }

  m_GLcontext = SDL_GL_CreateContext(m_win);
  if (!m_GLcontext) {
    lg::e(TAG, "Window error: ", SDL_GetError());
  }

  lg::i(TAG, "Window: init...");

  glEnable(GL_DEPTH_TEST); // zbuffer
  glEnable(GL_LIGHTING);   // lighting
  glEnable(GL_LIGHT0);     // light0
  glEnable(GL_NORMALIZE);  // normalize the vectors

  glFrontFace(GL_CW); // Front facing faces are taken clockwise
  glEnable(GL_COLOR_MATERIAL);
  glColorMaterial(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE);
  glEnable(GL_POLYGON_OFFSET_FILL);

  // move fragment generated by rasterization back
  glPolygonOffset(1.0f, 1.0f); // set back
}

// clean up window and context
SmartWindow::~SmartWindow() {
  static const auto TAG = __func__;

  lg::i(TAG, "deleting context and window");
  SDL_GL_DeleteContext(m_GLcontext);
  SDL_DestroyWindow(m_win);
}

// hides the window
void SmartWindow::hide() { SDL_HideWindow(m_win); }

// sets up the viewport to match the window size.
void SmartWindow::setupViewport() { glViewport(0, 0, m_width, m_height); }

// shows the window
void SmartWindow::show() { SDL_ShowWindow(m_win); }

void SmartWindow::refresh() {
  glFinish();
  SDL_GL_SwapWindow(m_win);
}

// QUESTI DA CAMBIARE, SENZA USARE LE LAMBDA POSSIBILMENTE

// executes fn() in pixel coordinates mode, after coloring the whole window
// with a solid color c.
/*
void SmartWindow::color_whole_area(const Color& c, std::function<void()> fn) {
  draw_on_pixels([&]{
    glColor3f(c.r, c.g, c.b);

    glBegin(GL_POLYGON);
    {
      glVertex2f(0.0f, 0.0f);

      glVertex2f(width, 0.0f);

      glVertex2f(width, height);

      glVertex2f(0.0f, height);
    }
    glEnd();

    fn();
  });
}

// Sets the world coordinates (x,y) to map into the screen coordinates,
// then calls fn(), cleans up after.
// remember to reset projection afterwards if it's still needed.
void SmartWindow::draw_on_pixels(std::function<void()> fn) {
  glDisable(GL_LIGHTING);
  glDisable(GL_DEPTH_TEST);

  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();

  glMatrixMode(GL_MODELVIEW);

  // It's important to create a new scope here; otherwise, we're just erasing
  // the old matrix.
  m_ctx.matrix_scope([&]{
    glLoadIdentity();

    glTranslatef(-1, -1, 0);

    glScalef(2.0 / width, 2.0 / height, 1);

    fn();
  });

  glEnable(GL_DEPTH_TEST);
  glEnable(GL_LIGHTING);
}


// Like color_whole_area() but with a texture. Useful to show images.
void SmartWindow::texture_whole_area(TexID t, std::function<void()> fn) {
  draw_on_pixels([&]{
    glColor3f(1.0f, 1.0f, 1.0f);

    glEnable(GL_TEXTURE_2D);
    glBindTexture(GL_TEXTURE_2D, t);

    glBegin(GL_POLYGON);
    {
      glTexCoord2f(0.0f, 0.0f);
      glVertex2f(0.0f, 0.0f);

      glTexCoord2f(1.0f, 0.0f);
      glVertex2f(width, 0.0f);

      glTexCoord2f(1.0f, 1.0f);
      glVertex2f(width, height);

      glTexCoord2f(0.0f, 1.0f);
      glVertex2f(0.0f, height);
    }
    glEnd();

    glDisable(GL_TEXTURE_2D);

    fn();
  });
}*/
} // namespace agl
